## Longest Palindromic Substring
Given a string s, return the longest palindromic substring in s.
Example 1:

Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
Example 2:
Input: s = "cbbd"
Output: "bb"
Constraints:
1 <= s.length <= 1000
s consist of only digits and English letters.

## Answer:
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if not s:
            return ""

        def expand(l: int, r: int) -> tuple[int, int]:
            # expand while in bounds and characters match
            while l >= 0 and r < len(s) and s[l] == s[r]:
                l -= 1
                r += 1
            # after the loop, [l+1, r) is the valid palindrome window
            return l + 1, r

        start, end = 0, 1  # best window s[start:end]
        for i in range(len(s)):
            # odd-length center at i
            l1, r1 = expand(i, i)
            # even-length center between i and i+1
            l2, r2 = expand(i, i + 1)

            # update with the longer window
            if r1 - l1 > end - start:
                start, end = l1, r1
            if r2 - l2 > end - start:
                start, end = l2, r2
        return s[start:end]


## Explain:
How it works (step by step)
# Empty guard
if not s: return ""
Return empty string for empty input.

# Center expansion helper

def expand(l, r):
    while l >= 0 and r < len(s) and s[l] == s[r]:
        l -= 1; r += 1
    return l + 1, r

Start with a center (l, r) and expand outward as long as characters match.
When the loop stops, indices have stepped one past the palindrome on both sides, so the valid slice is [l+1, r).

# Track best window

start, end = 0, 1

# Keep the best palindrome as a half‑open slice s[start:end]. Initialize to the first character.
Try every center

for i in range(len(s)):
    l1, r1 = expand(i, i)       # odd center
    l2, r2 = expand(i, i + 1)   # even center

Odd palindromes have a single-char center (i, i).
Even palindromes have a gap center (i, i+1).

# Update the best result

if r1 - l1 > end - start: start, end = l1, r1
if r2 - l2 > end - start: start, end = l2, r2

Compare candidate lengths to the current best. Two separate ifs let the even case still win after the odd case.

# Return the substring
return s[start:end]

## Dry run: "babad"
i=0: odd → "b", even → "" → best "b".
i=1: odd expands to "bab" → update best to "bab". even → "".
i=2: odd expands to "aba" (length 3, ties with "bab"). even → "".

Others don’t beat length 3.
Result: "bab" (or "aba" is also valid).

## Complexity

Time: O(n^2) (each center can expand up to O(n)).

Space: O(1).

## Common pitfalls

Forgetting the even center (i, i+1) → you’d miss cases like "abba".
Returning the wrong window after expand—must use [l+1, r).
Off‑by‑one on lengths: compare r - l vs end - start (since end is exclusive).
